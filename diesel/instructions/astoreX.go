package instructions

import (
		"../runtime"
	"../../utils"
		)

type I_astoreX struct {
}

func init()  {
	INSTRUCTION_MAP[0x4b] = &I_astoreX{}
	INSTRUCTION_MAP[0x4c] = &I_astoreX{}
	INSTRUCTION_MAP[0x4d] = &I_astoreX{}
	INSTRUCTION_MAP[0x4e] = &I_astoreX{}
}

func (s I_astoreX)Stroke(ctx *runtime.Context) error {
	utils.Log(1, "astoreX exce >>>>>>>>>\n")

	index := ctx.Code[ctx.PC - 1] - 0x4b
	ref, _ := ctx.CurrentFrame.PopFrame()

	ctx.CurrentAborigines.SetAborigines(uint32(index), ref)

	return nil
}

func (s I_astoreX)Test(octx *runtime.Context) *runtime.Context {

	f1 := new(runtime.Frame)
	f1.PushFrame(9999)

	var a []interface{}
	a = append(append(append(append(a, 1), 2), 3), 4)

	return &runtime.Context{
		PC: 0,
		Code: []byte{0x4e, 0x2},
		CurrentFrame: f1,
		CurrentAborigines: &runtime.Aborigines{
			Layers: a,
		},
	}
}
/**
======================================================================================
		操作				||		将一个 reference 类型数据保存到局部变量表中
======================================================================================
						||		astore_<n>
						||------------------------------------------------------------
						||		index
						||------------------------------------------------------------
						||
		格式				||------------------------------------------------------------
						||		
						||------------------------------------------------------------
						||		
						||------------------------------------------------------------
						||		
======================================================================================
						||		astore_0 = 75(0x4b)
						||------------------------------------------------------------
						||		astore_1 = 76(0x4c)
		结构				||------------------------------------------------------------
						||		astore_2 = 77(0x4d)
						||------------------------------------------------------------
						||		astore_3 = 78(0x4e)
======================================================================================
						||		...，objectref →
	   操作数栈			||------------------------------------------------------------
						||		...，
======================================================================================
						||		
						||		<n>必须是一个指向当前栈帧(§2.6)局部变量表的索引值，
						||		而在操作数栈 栈顶的 objectref 必须是 returnAddress 或者 reference 类型的数据，
						||		这个数据将从操作数栈出栈，然后保存到<n>所指向的局部变量表位置中。
		描述				||
						||
						||
						||
						||
======================================================================================
						||		
						||
						||
	   链接时异常			||
						||		
						||		
						||		
======================================================================================
						||
						||
	   运行时异常			||
						||
						||
======================================================================================
						||
						||		astore_<n>指令可以与 returnAddress 类型的数据配合来实现 Java 语言 中的 finally 子句(参见§3.13，
						||		“编译 fianlly”)。但是 aload_<n>指令不可以用来从局部变量表加载 returnAddress 类型的数据到操作数栈，
		注意				||		这 种 astore_<n>指令的不对称性是有意设计的。
						||
						||		astore_<n>指令族中的每一条指令都与使用<n>作为 index 参数的 astore 指令作的作用一致，仅仅除了操作数<n>是隐式包含在指令中这点不同而已。
						||
======================================================================================
 */