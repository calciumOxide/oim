package instructions

import (
	"../runtime"
	"../../utils"
	"../../types"
			)

type I_wide struct {
}

func init()  {
	INSTRUCTION_MAP[0xc4] = &I_wide{}
}

func (s I_wide)Stroke(ctx *runtime.Context) error {
	utils.Log(1, "wide exce >>>>>>>>>\n")

	ctx.PushWide()
	return nil
}

func (s I_wide)Test(octx *runtime.Context) *runtime.Context {
	f := new(runtime.Frame)
	f.PushFrame(&types.Jarray{
		Reference: []types.Jbyte{1, 2, 3, 4},
	})
	f.PushFrame(types.Jlong(9))
	f.PushFrame(types.Jlong(9))
	a := new(runtime.Aborigines)
	a.Layers = append(a.Layers, &[]uint32{1234})
	return &runtime.Context{
		Code: []byte{0x0},
		CurrentFrame: f,
		CurrentAborigines: a,
	}
}
/**
======================================================================================
		操作				||		扩展局部变量表索引
======================================================================================
						||		wide
						||------------------------------------------------------------
						||		<opcode>
						||------------------------------------------------------------
						||		indexbyte1
		格式				||------------------------------------------------------------
						||		indexbyte2
						||------------------------------------------------------------
						||		当<opcode>为 iload，fload，aload，lload，dload，istore，fstore， astore，lstore，dstore 以及 ret 指令之一时。
						||------------------------------------------------------------
						||		
======================================================================================
						||		wide
						||------------------------------------------------------------
						||		iinc
						||------------------------------------------------------------
						||		indexbyte1
		格式				||------------------------------------------------------------
						||		indexbyte2
						||------------------------------------------------------------
						||		constbyte1
		格式				||------------------------------------------------------------
						||		constbyte2
						||------------------------------------------------------------
						||
======================================================================================
		结构				||		wide = 196(0xc4)
======================================================================================
						||		...，  →
	   操作数栈			||------------------------------------------------------------
						||		„，
======================================================================================
						||
		描述				||		与被扩展的指令一致

wide 指令用于扩展其他指令的行为，取决于被不同扩展的指令，它可以有两 种形式。第一种形式是当被扩展指令为 iload，fload，aload，lload，
dload，istore，fstore，astore，lstore，dstore 以及 ret 指令之 一时使用，第二种形式仅当被扩展指令为 iinc 时使用。

无论哪种形式，wide 指令后面都跟随者被扩展指令的操作码，之后是两个无 符号 byte 型数值 indexbyte1 和 indexbyte2，它们通过(indexbyte1 << 8)| indexbyte2的形式构成一个指向当前栈帧(§2.6)的局部变量表的 16 位无符号索引。
随后，wide 使用这个被新计算出来的索引值替换掉被扩展指令中的索引参数，如果被扩展指令为 lload，dload，lstore 以及 dstore 指令，那 index 和 index+1 都必须为合法的局部变量索引值。
对于 wide 指令的第二种形式，在 indexbyte1 和 indexbyte2 后面还有另外两个无符 号 byte 型数值 constbyte1 和 constbyte2，它们将以(constbyte1 << 8)| constbyte2的形式构成一个有符号的16位常量。

被 wide 指令扩展的那些指令，行为上与原有指令的语义没有任何区别，仅仅 是索引参数被替换了而已。对于 wide 指令的第二种形式，则是有了更大的增 加范围。
						||
======================================================================================
						||		
	   运行时异常			||
						||
======================================================================================
						||
		注意				||
						||虽然我们所 wide 指令扩展了其他指令。实际上更准确的 wide 指令修改了这 些指令的操作数，而不是改变这些指令的本来语义。对于 iinc 指令来说，则
是被修改了全部两个操作数。被 wide 指令扩展的那些指令不应当脱离 wide 指令直接执行，即不能有任何跳转指令的目标是这些跟随在 wde 指令之后的字 节码指令。
						||
						||
======================================================================================
 */