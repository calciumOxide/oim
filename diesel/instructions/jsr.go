package instructions

import (
	"../runtime"
	"../../utils"
	"../../types"
			)

type I_jsr struct {
}

func init()  {
	INSTRUCTION_MAP[0xa8] = &I_jsr{}
}

func (s I_jsr)Stroke(ctx *runtime.Context) error {
	utils.Log(1, "jsr exce >>>>>>>>>\n")

	index := uint32(ctx.Code[ctx.PC]) << 8 | uint32(ctx.Code[ctx.PC + 1])
	ctx.PC += 2

	ctx.CurrentFrame.PushFrame(types.Jaddress(index))
	return nil
}

func (s I_jsr)Test() *runtime.Context {
	f := new(runtime.Frame)
	f.PushFrame(&types.Jarray{
		Reference: []types.Jbyte{1, 2, 3, 4},
	})
	f.PushFrame(types.Jint(9))
	f.PushFrame(types.Jint(9))
	a := new(runtime.Aborigines)
	a.Layers = append(a.Layers, &[]uint32{1234})
	return &runtime.Context{
		Code: []byte{0x0},
		CurrentFrame: f,
		CurrentAborigines: a,
	}
}
/**
======================================================================================
		操作				||		程序段落跳转
======================================================================================
						||		jsr
						||------------------------------------------------------------
						||		branchbyte1
						||------------------------------------------------------------
						||		branchbyte2
		格式				||------------------------------------------------------------
						||		
						||------------------------------------------------------------
						||		
						||------------------------------------------------------------
						||		
======================================================================================
		结构				||		jsr = 168(0xa8)
======================================================================================
						||		...， →
	   操作数栈			||------------------------------------------------------------
						||		...，address
======================================================================================
						||
						||		address 是一个 returnAddress 类型的数据，它由 jsr 指令推入操作数栈 中。无符号 byte 型数据 branchbyte1 和 branchbyte2 用于构建一个 16
位有符号的分支偏移量，构建方式为(branchbyte1 << 8)| branchbyte2。 指令执行时，将产生一个当前位置的偏移坐标，并压入到操作数栈中。跳转目 标地址必须在 jsr 指令所在的方法之内。
		描述				||
						||
======================================================================================
						||		
	   运行时异常			||
						||
======================================================================================
						||
						||
						||请注意，jsr 指令将 address 压入到操作数栈，ret 指令从局部变量表中把 它取出，这种不对称的操作是故意设计的。
在Oracle的实现Java语言编译器中，Java SE 6前的版本是使用jsr和 ret 指令配合来实现 finally 语句块的。详细信息读者可以参见§3.13“编 译 finally 语句块”和§4.10.2.5“异常与 finally”。
		注意				||
						||
						||
						||
======================================================================================
 */